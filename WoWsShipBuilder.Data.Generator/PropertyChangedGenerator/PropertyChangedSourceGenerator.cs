using System;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using WoWsShipBuilder.Data.Generator.Utilities;

namespace WoWsShipBuilder.Data.Generator.PropertyChangedGenerator;

[Generator(LanguageNames.CSharp)]
public class PropertyChangedSourceGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat FullyQualifiedWithNullableFormat = SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var properties = context.SyntaxProvider.ForAttributeWithMetadataName("WoWsShipBuilder.Infrastructure.Utility.ObservableAttribute", CouldBeObservableField, ProcessField);
        var aggregate = properties
            .Collect()
            .SelectMany((data, _) => data.GroupBy(field => field.ClassName).Select(grouping => new ClassFields(grouping.Key, grouping.ToEquatableArray())));
        context.RegisterSourceOutput(aggregate, GenerateClassProperties);
    }

    private static bool CouldBeObservableField(SyntaxNode node, CancellationToken _)
    {
        return node is VariableDeclaratorSyntax { Parent: VariableDeclarationSyntax { Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax or RecordDeclarationSyntax, AttributeLists.Count: > 0 } } };
    }

    private static FieldData ProcessField(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        var fieldSymbol = (IFieldSymbol)context.TargetSymbol;
        var propertyName = char.ToUpper(fieldSymbol.Name[0]) + fieldSymbol.Name[1..];
        var type = fieldSymbol.Type.ToDisplayString(FullyQualifiedWithNullableFormat);
        var className = fieldSymbol.ContainingType.Name;
        var containingNamespace = fieldSymbol.ContainingType.ContainingNamespace.ToFullyQualifiedMetadataName();
        var visibility = (Visibility)(context.Attributes[0].NamedArguments.FirstOrDefault(arg => arg.Key == "SetterVisibility").Value.Value ?? Visibility.Public);
        var visibilityModifier = visibility switch
        {
            Visibility.Public => string.Empty,
            Visibility.Protected => "protected ",
            Visibility.Internal => "internal ",
            Visibility.Private => "private ",
            _ => throw new InvalidOperationException(),
        };

        token.ThrowIfCancellationRequested();
        return new(fieldSymbol.Name, propertyName, type, className, containingNamespace, visibilityModifier);
    }

    private static void GenerateClassProperties(SourceProductionContext context, ClassFields classFields)
    {
        var builder = new SourceBuilder();
        builder.Line("// <auto-generated />").Line("#nullable enable");

        // if there was a grouping, there exists at least one field in the class
        var classNamespace = classFields.Fields[0].Namespace;
        using (builder.Namespace(classNamespace))
        {
            using (builder.Class(classFields.ClassName))
            {
                foreach (var fieldData in classFields.Fields)
                {
                    using (builder.Block($"public {fieldData.Type} {fieldData.PropertyName}"))
                    {
                        builder.Line($"get => this.{fieldData.FieldName};");
                        builder.Line($"{fieldData.VisibilityModifier}set => global::ReactiveUI.IReactiveObjectExtensions.RaiseAndSetIfChanged(this, ref this.{fieldData.FieldName}, value);");
                    }
                }
            }
        }

        context.AddSource($"{classNamespace}.{classFields.ClassName}.g.cs", builder.ToString());
    }
}
