using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using WoWsShipBuilder.Data.Generator.Utilities;

namespace WoWsShipBuilder.Data.Generator.PropertyChangedGenerator;

[Generator(LanguageNames.CSharp)]
public class PropertyChangedSourceGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat FullyQualifiedWithNullableFormat = SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var properties = context.SyntaxProvider.ForAttributeWithMetadataName("WoWsShipBuilder.Infrastructure.Utility.ObservableAttribute", CouldBeObservableField, ProcessField);
        context.RegisterSourceOutput(properties, GeneratePropertyCode);
    }

    private static bool CouldBeObservableField(SyntaxNode node, CancellationToken token)
    {
        return node is VariableDeclaratorSyntax { Parent: VariableDeclarationSyntax { Parent: FieldDeclarationSyntax { Parent: ClassDeclarationSyntax or RecordDeclarationSyntax, AttributeLists.Count: > 0 } } };
    }

    private sealed record FieldData(string FieldName, string PropertyName, string Type, string ClassName, string Namespace, string VisibilityModifier);

    private static FieldData ProcessField(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        var fieldSymbol = (IFieldSymbol)context.TargetSymbol;
        var propertyName = char.ToUpper(fieldSymbol.Name[0]) + fieldSymbol.Name[1..];
        var type = fieldSymbol.Type.ToDisplayString(FullyQualifiedWithNullableFormat);
        var className = fieldSymbol.ContainingType.Name;
        var containingNamespace = fieldSymbol.ContainingType.ContainingNamespace.ToFullyQualifiedMetadataName();
        var visibility = (Visibility)(context.Attributes[0].NamedArguments.FirstOrDefault(arg => arg.Key == "SetterVisibility").Value.Value ?? Visibility.Public);
        var visibilityModifier = visibility switch
        {
            Visibility.Public => string.Empty,
            Visibility.Protected => "protected ",
            Visibility.Internal => "internal ",
            Visibility.Private => "private ",
            _ => throw new InvalidOperationException(),
        };

        token.ThrowIfCancellationRequested();
        return new(fieldSymbol.Name, propertyName, type, className, containingNamespace, visibilityModifier);
    }

    private static void GeneratePropertyCode(SourceProductionContext context, FieldData fieldData)
    {
        context.CancellationToken.ThrowIfCancellationRequested();
        var builder = new SourceBuilder();
        builder.Line("// <auto-generated />").Line("#nullable enable");
        using (builder.Namespace(fieldData.Namespace))
        {
            using (builder.Class(fieldData.ClassName))
            {
                using (builder.Block($"public {fieldData.Type} {fieldData.PropertyName}"))
                {
                    builder.Line($"get => this.{fieldData.FieldName};");
                    builder.Line($"{fieldData.VisibilityModifier}set => global::ReactiveUI.IReactiveObjectExtensions.RaiseAndSetIfChanged(this, ref this.{fieldData.FieldName}, value);");
                }
            }
        }

        context.CancellationToken.ThrowIfCancellationRequested();
        context.AddSource($"{fieldData.Namespace}.{fieldData.ClassName}_{fieldData.FieldName}.g.cs", builder.ToString());
    }

    private static bool ViewModelFilter(SyntaxNode syntaxNode, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
        {
            return false;
        }

        return classDeclaration.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PartialKeyword));
    }

    private static ITypeSymbol? GetViewModelOrNull(GeneratorSyntaxContext context, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        return context.SemanticModel.GetDeclaredSymbol(typeDeclaration);
    }

    private static SourceGenFilterResult GetObservableFields(ITypeSymbol symbol, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        string className = symbol.Name;
        string classNamespace = symbol.ContainingNamespace.ToDisplayString();
        List<IFieldSymbol> fields = symbol.GetMembers().OfType<IFieldSymbol>().Where(field => field.GetAttributes().Any(attr => attr.AttributeClass!.Name == "ObservableAttribute")).ToList();
        return new(className, classNamespace, fields);
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<SourceGenFilterResult> viewmodels)
    {
        var logMessages = new StringBuilder();
        foreach (var viewmodel in viewmodels)
        {
            var classStart = $@"
using ReactiveUI;

namespace {viewmodel.ElementNamespace};

#nullable enable
public partial class {viewmodel.ElementName}
{{
";
            const string classEnd = @"
}
#nullable restore
";

            var classBuilder = new StringBuilder(classStart);
            foreach (var field in viewmodel.Items)
            {
                var propertyName = char.ToUpper(field.Name.First()) + field.Name.Substring(1);
                var fieldAttribute = field.GetAttributes().First(a => a.AttributeClass!.Name == "ObservableAttribute");
                var setterVisibility = (Visibility)(fieldAttribute.NamedArguments.FirstOrDefault(arg => arg.Key == "SetterVisibility").Value.Value ?? Visibility.Public);
                var setterVisibilityString = setterVisibility switch
                {
                    Visibility.Public => string.Empty,
                    Visibility.Protected => "protected ",
                    Visibility.Internal => "internal ",
                    Visibility.Private => "private ",
                    _ => throw new InvalidOperationException(),
                };
                logMessages.AppendLine("#4");
                classBuilder.AppendLine($@"
    public {field.Type} {propertyName}
    {{
        get => this.{field.Name};
        {setterVisibilityString}set => this.RaiseAndSetIfChanged(ref this.{field.Name}, value);
    }}");
            }

            classBuilder.AppendLine(classEnd);
            context.AddSource($"{viewmodel.ElementName}.g.cs", SourceText.From(classBuilder.ToString(), Encoding.UTF8));
        }
    }

    private record struct SourceGenFilterResult(string ElementName, string ElementNamespace, List<IFieldSymbol> Items);
}
